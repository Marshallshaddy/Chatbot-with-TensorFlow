/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ADDDEBUGINFOPASS
#define GEN_PASS_DECL_COLLAPSESHAPEPASS
#define GEN_PASS_DECL_COMPOSEEXTRACTINSERTSLICEPASS
#define GEN_PASS_DECL_FUSIONPASS
#define GEN_PASS_DECL_GMLSTSIMTFYPASS
#define GEN_PASS_DECL_GMLSTTOGPUPASS
#define GEN_PASS_DECL_GMLSTTOSCF
#define GEN_PASS_DECL_GREEDYFUSIONPASS
#define GEN_PASS_DECL_REWRITEVECTORCONTRACTPASS
#define GEN_PASS_DECL_REWRITEVECTORMULTIREDUCTIONPASS
#define GEN_PASS_DECL_REWRITEVECTORTRANSPOSEPASS
#define GEN_PASS_DECL_SCALARIZATIONPASS
#define GEN_PASS_DECL_SIMPLIFYDEADCOPYPASS
#define GEN_PASS_DECL_TILINGCWISEPASS
#define GEN_PASS_DECL_TILINGGPUWARPPASS
#define GEN_PASS_DECL_TILINGPASS
#define GEN_PASS_DECL_TILINGSOFTMAXPASS
#define GEN_PASS_DECL_TRANSFORMMAPFORCPUPASS
#define GEN_PASS_DECL_TRANSFORMMATMULFORCPUPASS
#define GEN_PASS_DECL_TRANSFORMMATMULFORTRITONPASS
#define GEN_PASS_DECL_TRANSFORMREDUCEFORCPUPASS
#define GEN_PASS_DECL_TRANSFORMREVERSEFORCPUPASS
#define GEN_PASS_DECL_TRANSFORMSCATTERFORCPUPASS
#define GEN_PASS_DECL_TRANSFORMSORTFORCPUPASS
#define GEN_PASS_DECL_TRANSFORMTRANSPOSEFORCPUPASS
#define GEN_PASS_DECL_VECTORIZECOPYPASS
#define GEN_PASS_DECL_VECTORIZEFORCPUPASS
#define GEN_PASS_DECL_VECTORIZEFORGPUPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// AddDebugInfoPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ADDDEBUGINFOPASS
#undef GEN_PASS_DECL_ADDDEBUGINFOPASS
#endif // GEN_PASS_DECL_ADDDEBUGINFOPASS
#ifdef GEN_PASS_DEF_ADDDEBUGINFOPASS
namespace impl {

template <typename DerivedT>
class AddDebugInfoPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddDebugInfoPassBase;

  AddDebugInfoPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddDebugInfoPassBase(const AddDebugInfoPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("add-debug-info");
  }
  ::llvm::StringRef getArgument() const override { return "add-debug-info"; }

  ::llvm::StringRef getDescription() const override { return "Add debug info for the whole module"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddDebugInfoPass");
  }
  ::llvm::StringRef getName() const override { return "AddDebugInfoPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::LLVM::LLVMDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddDebugInfoPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ADDDEBUGINFOPASS
#endif // GEN_PASS_DEF_ADDDEBUGINFOPASS

//===----------------------------------------------------------------------===//
// CollapseShapePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COLLAPSESHAPEPASS
struct CollapseShapePassOptions {
  int64_t retainTrailingDims = 0;
};
#undef GEN_PASS_DECL_COLLAPSESHAPEPASS
#endif // GEN_PASS_DECL_COLLAPSESHAPEPASS
#ifdef GEN_PASS_DEF_COLLAPSESHAPEPASS
namespace impl {

template <typename DerivedT>
class CollapseShapePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CollapseShapePassBase;

  CollapseShapePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CollapseShapePassBase(const CollapseShapePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-collapse-shape");
  }
  ::llvm::StringRef getArgument() const override { return "gml-collapse-shape"; }

  ::llvm::StringRef getDescription() const override { return "Collapse dimensions of bcasts, reductions, and cwise ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CollapseShapePass");
  }
  ::llvm::StringRef getName() const override { return "CollapseShapePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CollapseShapePassBase<DerivedT>)

  CollapseShapePassBase(const CollapseShapePassOptions &options) : CollapseShapePassBase() {
    retainTrailingDims = options.retainTrailingDims;
  }
protected:
  ::mlir::Pass::Option<int64_t> retainTrailingDims{*this, "retain-trailing-dims", ::llvm::cl::desc("Number of trailing dimensions that will not be collapsed."), ::llvm::cl::init(0)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COLLAPSESHAPEPASS
#endif // GEN_PASS_DEF_COLLAPSESHAPEPASS

//===----------------------------------------------------------------------===//
// ComposeExtractInsertSlicePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_COMPOSEEXTRACTINSERTSLICEPASS
#undef GEN_PASS_DECL_COMPOSEEXTRACTINSERTSLICEPASS
#endif // GEN_PASS_DECL_COMPOSEEXTRACTINSERTSLICEPASS
#ifdef GEN_PASS_DEF_COMPOSEEXTRACTINSERTSLICEPASS
namespace impl {

template <typename DerivedT>
class ComposeExtractInsertSlicePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ComposeExtractInsertSlicePassBase;

  ComposeExtractInsertSlicePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ComposeExtractInsertSlicePassBase(const ComposeExtractInsertSlicePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-compose-extract-insert-slice");
  }
  ::llvm::StringRef getArgument() const override { return "gml-compose-extract-insert-slice"; }

  ::llvm::StringRef getDescription() const override { return "Compose tensor.extract_slice/insert_slice ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ComposeExtractInsertSlicePass");
  }
  ::llvm::StringRef getName() const override { return "ComposeExtractInsertSlicePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ComposeExtractInsertSlicePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_COMPOSEEXTRACTINSERTSLICEPASS
#endif // GEN_PASS_DEF_COMPOSEEXTRACTINSERTSLICEPASS

//===----------------------------------------------------------------------===//
// FusionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUSIONPASS
struct FusionPassOptions {
  std::string producerLabel;
  std::string consumerLabel;
};
#undef GEN_PASS_DECL_FUSIONPASS
#endif // GEN_PASS_DECL_FUSIONPASS
#ifdef GEN_PASS_DEF_FUSIONPASS
namespace impl {

template <typename DerivedT>
class FusionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FusionPassBase;

  FusionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusionPassBase(const FusionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-fusion");
  }
  ::llvm::StringRef getArgument() const override { return "gml-fusion"; }

  ::llvm::StringRef getDescription() const override { return "Fuse producers in into `gml_st.materialize` operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusionPass");
  }
  ::llvm::StringRef getName() const override { return "FusionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusionPassBase<DerivedT>)

  FusionPassBase(const FusionPassOptions &options) : FusionPassBase() {
    producerLabel = options.producerLabel;
    consumerLabel = options.consumerLabel;
  }
protected:
  ::mlir::Pass::Option<std::string> producerLabel{*this, "producer-label", ::llvm::cl::desc("Producer label.")};
  ::mlir::Pass::Option<std::string> consumerLabel{*this, "consumer-label", ::llvm::cl::desc("Consumer label.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FUSIONPASS
#endif // GEN_PASS_DEF_FUSIONPASS

//===----------------------------------------------------------------------===//
// GmlStSimtfyPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GMLSTSIMTFYPASS
struct GmlStSimtfyPassOptions {
  std::string blockDistributionLabel = "block";
};
#undef GEN_PASS_DECL_GMLSTSIMTFYPASS
#endif // GEN_PASS_DECL_GMLSTSIMTFYPASS
#ifdef GEN_PASS_DEF_GMLSTSIMTFYPASS
namespace impl {

template <typename DerivedT>
class GmlStSimtfyPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = GmlStSimtfyPassBase;

  GmlStSimtfyPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  GmlStSimtfyPassBase(const GmlStSimtfyPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-simtfy");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-simtfy"; }

  ::llvm::StringRef getDescription() const override { return "Lower nested `gml_st.parallel` to `gpu.launch`"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GmlStSimtfyPass");
  }
  ::llvm::StringRef getName() const override { return "GmlStSimtfyPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::AffineDialect>();

  registry.insert<::mlir::arith::ArithDialect>();

  registry.insert<::mlir::gpu::GPUDialect>();

  registry.insert<::mlir::scf::SCFDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GmlStSimtfyPassBase<DerivedT>)

  GmlStSimtfyPassBase(const GmlStSimtfyPassOptions &options) : GmlStSimtfyPassBase() {
    blockDistributionLabel = options.blockDistributionLabel;
  }
protected:
  ::mlir::Pass::Option<std::string> blockDistributionLabel{*this, "block-distribution-label", ::llvm::cl::desc("Direct children of `gml_st.parallel` loops with this distribution type are distributed over blocks."), ::llvm::cl::init("block")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GMLSTSIMTFYPASS
#endif // GEN_PASS_DEF_GMLSTSIMTFYPASS

//===----------------------------------------------------------------------===//
// GmlStToGpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GMLSTTOGPUPASS
struct GmlStToGpuPassOptions {
  std::string warpDistributionLabel = "warp";
};
#undef GEN_PASS_DECL_GMLSTTOGPUPASS
#endif // GEN_PASS_DECL_GMLSTTOGPUPASS
#ifdef GEN_PASS_DEF_GMLSTTOGPUPASS
namespace impl {

template <typename DerivedT>
class GmlStToGpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = GmlStToGpuPassBase;

  GmlStToGpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  GmlStToGpuPassBase(const GmlStToGpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-to-gpu");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-to-gpu"; }

  ::llvm::StringRef getDescription() const override { return "Lower nested `gml_st.parallel` to `gpu.launch`"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GmlStToGpuPass");
  }
  ::llvm::StringRef getName() const override { return "GmlStToGpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::gpu::GPUDialect>();

  registry.insert<::mlir::vector::VectorDialect>();

  registry.insert<::mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GmlStToGpuPassBase<DerivedT>)

  GmlStToGpuPassBase(const GmlStToGpuPassOptions &options) : GmlStToGpuPassBase() {
    warpDistributionLabel = options.warpDistributionLabel;
  }
protected:
  ::mlir::Pass::Option<std::string> warpDistributionLabel{*this, "warp-distribution-label", ::llvm::cl::desc("Direct children of `gml_st.parallel` loops with this distribution type are distributed over warps."), ::llvm::cl::init("warp")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GMLSTTOGPUPASS
#endif // GEN_PASS_DEF_GMLSTTOGPUPASS

//===----------------------------------------------------------------------===//
// GmlStToScf
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GMLSTTOSCF
#undef GEN_PASS_DECL_GMLSTTOSCF
#endif // GEN_PASS_DECL_GMLSTTOSCF
#ifdef GEN_PASS_DEF_GMLSTTOSCF
namespace impl {

template <typename DerivedT>
class GmlStToScfBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = GmlStToScfBase;

  GmlStToScfBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  GmlStToScfBase(const GmlStToScfBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lower `gml_st.loop` to SCF loops and parallel loops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GmlStToScf");
  }
  ::llvm::StringRef getName() const override { return "GmlStToScf"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::scf::SCFDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GmlStToScfBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GMLSTTOSCF
#endif // GEN_PASS_DEF_GMLSTTOSCF

//===----------------------------------------------------------------------===//
// GreedyFusionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GREEDYFUSIONPASS
struct GreedyFusionPassOptions {
  bool distribute = true;
  ::llvm::ArrayRef<int64_t> tileSizes;
  std::string distributionLabel;
};
#undef GEN_PASS_DECL_GREEDYFUSIONPASS
#endif // GEN_PASS_DECL_GREEDYFUSIONPASS
#ifdef GEN_PASS_DEF_GREEDYFUSIONPASS
namespace impl {

template <typename DerivedT>
class GreedyFusionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = GreedyFusionPassBase;

  GreedyFusionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  GreedyFusionPassBase(const GreedyFusionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-greedy-fusion");
  }
  ::llvm::StringRef getArgument() const override { return "gml-greedy-fusion"; }

  ::llvm::StringRef getDescription() const override { return "Pass to tile the root operation and to greedily fuse producers into it."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GreedyFusionPass");
  }
  ::llvm::StringRef getName() const override { return "GreedyFusionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GreedyFusionPassBase<DerivedT>)

  GreedyFusionPassBase(const GreedyFusionPassOptions &options) : GreedyFusionPassBase() {
    distribute = options.distribute;
    tileSizes = options.tileSizes;
    distributionLabel = options.distributionLabel;
  }
protected:
  ::mlir::Pass::Option<bool> distribute{*this, "distribute", ::llvm::cl::desc("Generate gml_st.parallel or gml_st.for"), ::llvm::cl::init(true)};
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Tile sizes"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::Option<std::string> distributionLabel{*this, "distribution-label", ::llvm::cl::desc("Distribution label for generated gml_st.parallel")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GREEDYFUSIONPASS
#endif // GEN_PASS_DEF_GREEDYFUSIONPASS

//===----------------------------------------------------------------------===//
// RewriteVectorContractPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REWRITEVECTORCONTRACTPASS
#undef GEN_PASS_DECL_REWRITEVECTORCONTRACTPASS
#endif // GEN_PASS_DECL_REWRITEVECTORCONTRACTPASS
#ifdef GEN_PASS_DEF_REWRITEVECTORCONTRACTPASS
namespace impl {

template <typename DerivedT>
class RewriteVectorContractPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteVectorContractPassBase;

  RewriteVectorContractPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteVectorContractPassBase(const RewriteVectorContractPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("rewrite-vector-contract");
  }
  ::llvm::StringRef getArgument() const override { return "rewrite-vector-contract"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite vector.contract."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteVectorContractPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteVectorContractPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteVectorContractPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REWRITEVECTORCONTRACTPASS
#endif // GEN_PASS_DEF_REWRITEVECTORCONTRACTPASS

//===----------------------------------------------------------------------===//
// RewriteVectorMultiReductionPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REWRITEVECTORMULTIREDUCTIONPASS
#undef GEN_PASS_DECL_REWRITEVECTORMULTIREDUCTIONPASS
#endif // GEN_PASS_DECL_REWRITEVECTORMULTIREDUCTIONPASS
#ifdef GEN_PASS_DEF_REWRITEVECTORMULTIREDUCTIONPASS
namespace impl {

template <typename DerivedT>
class RewriteVectorMultiReductionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteVectorMultiReductionPassBase;

  RewriteVectorMultiReductionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteVectorMultiReductionPassBase(const RewriteVectorMultiReductionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("rewrite-vector-multi-reduction");
  }
  ::llvm::StringRef getArgument() const override { return "rewrite-vector-multi-reduction"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite vector.multi_reduction."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteVectorMultiReductionPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteVectorMultiReductionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteVectorMultiReductionPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REWRITEVECTORMULTIREDUCTIONPASS
#endif // GEN_PASS_DEF_REWRITEVECTORMULTIREDUCTIONPASS

//===----------------------------------------------------------------------===//
// RewriteVectorTransposePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REWRITEVECTORTRANSPOSEPASS
#undef GEN_PASS_DECL_REWRITEVECTORTRANSPOSEPASS
#endif // GEN_PASS_DECL_REWRITEVECTORTRANSPOSEPASS
#ifdef GEN_PASS_DEF_REWRITEVECTORTRANSPOSEPASS
namespace impl {

template <typename DerivedT>
class RewriteVectorTransposePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteVectorTransposePassBase;

  RewriteVectorTransposePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteVectorTransposePassBase(const RewriteVectorTransposePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("rewrite-vector-transpose");
  }
  ::llvm::StringRef getArgument() const override { return "rewrite-vector-transpose"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite vector.transpose."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteVectorTransposePass");
  }
  ::llvm::StringRef getName() const override { return "RewriteVectorTransposePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::LLVM::LLVMDialect>();

  registry.insert<::mlir::vector::VectorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteVectorTransposePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REWRITEVECTORTRANSPOSEPASS
#endif // GEN_PASS_DEF_REWRITEVECTORTRANSPOSEPASS

//===----------------------------------------------------------------------===//
// ScalarizationPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SCALARIZATIONPASS
#undef GEN_PASS_DECL_SCALARIZATIONPASS
#endif // GEN_PASS_DECL_SCALARIZATIONPASS
#ifdef GEN_PASS_DEF_SCALARIZATIONPASS
namespace impl {

template <typename DerivedT>
class ScalarizationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ScalarizationPassBase;

  ScalarizationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ScalarizationPassBase(const ScalarizationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("scalarize");
  }
  ::llvm::StringRef getArgument() const override { return "scalarize"; }

  ::llvm::StringRef getDescription() const override { return "Converts ops on tensors with 1 element to scalar ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ScalarizationPass");
  }
  ::llvm::StringRef getName() const override { return "ScalarizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<arith::ArithDialect>();

  registry.insert<gml_st::GmlStDialect>();

  registry.insert<scf::SCFDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ScalarizationPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SCALARIZATIONPASS
#endif // GEN_PASS_DEF_SCALARIZATIONPASS

//===----------------------------------------------------------------------===//
// SimplifyDeadCopyPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SIMPLIFYDEADCOPYPASS
#undef GEN_PASS_DECL_SIMPLIFYDEADCOPYPASS
#endif // GEN_PASS_DECL_SIMPLIFYDEADCOPYPASS
#ifdef GEN_PASS_DEF_SIMPLIFYDEADCOPYPASS
namespace impl {

template <typename DerivedT>
class SimplifyDeadCopyPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SimplifyDeadCopyPassBase;

  SimplifyDeadCopyPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyDeadCopyPassBase(const SimplifyDeadCopyPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("simplify-dead-copy");
  }
  ::llvm::StringRef getArgument() const override { return "simplify-dead-copy"; }

  ::llvm::StringRef getDescription() const override { return "Pass to simplify dead `memref.copy`."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyDeadCopyPass");
  }
  ::llvm::StringRef getName() const override { return "SimplifyDeadCopyPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  registry.insert<::mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyDeadCopyPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SIMPLIFYDEADCOPYPASS
#endif // GEN_PASS_DEF_SIMPLIFYDEADCOPYPASS

//===----------------------------------------------------------------------===//
// TilingCwisePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TILINGCWISEPASS
struct TilingCwisePassOptions {
  bool distribute_ = true;
  ::llvm::ArrayRef<int64_t> tileSizes_;
  std::string distributionLabel_;
};
#undef GEN_PASS_DECL_TILINGCWISEPASS
#endif // GEN_PASS_DECL_TILINGCWISEPASS
#ifdef GEN_PASS_DEF_TILINGCWISEPASS
namespace impl {

template <typename DerivedT>
class TilingCwisePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TilingCwisePassBase;

  TilingCwisePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TilingCwisePassBase(const TilingCwisePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-tiling-cwise");
  }
  ::llvm::StringRef getArgument() const override { return "gml-tiling-cwise"; }

  ::llvm::StringRef getDescription() const override { return "Tile and fuse all cwise ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TilingCwisePass");
  }
  ::llvm::StringRef getName() const override { return "TilingCwisePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TilingCwisePassBase<DerivedT>)

  TilingCwisePassBase(const TilingCwisePassOptions &options) : TilingCwisePassBase() {
    distribute_ = options.distribute_;
    tileSizes_ = options.tileSizes_;
    distributionLabel_ = options.distributionLabel_;
  }
protected:
  ::mlir::Pass::Option<bool> distribute_{*this, "distribute", ::llvm::cl::desc("Generate gml_st.parallel or gml_st.for"), ::llvm::cl::init(true)};
  ::mlir::Pass::ListOption<int64_t> tileSizes_{*this, "tile-sizes", ::llvm::cl::desc("Right-aligned tile sizes. Do not tile possible remaining dimensions"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::Option<std::string> distributionLabel_{*this, "distribution-label", ::llvm::cl::desc("Distribution label for generated gml_st.parallel")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TILINGCWISEPASS
#endif // GEN_PASS_DEF_TILINGCWISEPASS

//===----------------------------------------------------------------------===//
// TilingGPUWarpPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TILINGGPUWARPPASS
#undef GEN_PASS_DECL_TILINGGPUWARPPASS
#endif // GEN_PASS_DECL_TILINGGPUWARPPASS
#ifdef GEN_PASS_DEF_TILINGGPUWARPPASS
namespace impl {

template <typename DerivedT>
class TilingGPUWarpPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TilingGPUWarpPassBase;

  TilingGPUWarpPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TilingGPUWarpPassBase(const TilingGPUWarpPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-tiling-gpu-warp");
  }
  ::llvm::StringRef getArgument() const override { return "gml-tiling-gpu-warp"; }

  ::llvm::StringRef getDescription() const override { return "Tile warp-level ops for GPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TilingGPUWarpPass");
  }
  ::llvm::StringRef getName() const override { return "TilingGPUWarpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::gml_st::GmlStDialect>();

  registry.insert<::mlir::arith::ArithDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TilingGPUWarpPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TILINGGPUWARPPASS
#endif // GEN_PASS_DEF_TILINGGPUWARPPASS

//===----------------------------------------------------------------------===//
// TilingPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TILINGPASS
struct TilingPassOptions {
  std::string opName;
  std::string opLabel;
  bool distribute = true;
  ::llvm::ArrayRef<int64_t> tileSizes;
};
#undef GEN_PASS_DECL_TILINGPASS
#endif // GEN_PASS_DECL_TILINGPASS
#ifdef GEN_PASS_DEF_TILINGPASS
namespace impl {

template <typename DerivedT>
class TilingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TilingPassBase;

  TilingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TilingPassBase(const TilingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-tiling");
  }
  ::llvm::StringRef getArgument() const override { return "gml-tiling"; }

  ::llvm::StringRef getDescription() const override { return "Tile operations using TilingInterface to produce gml_st.for"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TilingPass");
  }
  ::llvm::StringRef getName() const override { return "TilingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TilingPassBase<DerivedT>)

  TilingPassBase(const TilingPassOptions &options) : TilingPassBase() {
    opName = options.opName;
    opLabel = options.opLabel;
    distribute = options.distribute;
    tileSizes = options.tileSizes;
  }
protected:
  ::mlir::Pass::Option<std::string> opName{*this, "op-name", ::llvm::cl::desc("Operation with this name is the anchor to latch on.")};
  ::mlir::Pass::Option<std::string> opLabel{*this, "op-label", ::llvm::cl::desc("Operation with this label is the anchor to latch on.")};
  ::mlir::Pass::Option<bool> distribute{*this, "distribute", ::llvm::cl::desc("Generate gml_st.parallel or gml_st.for"), ::llvm::cl::init(true)};
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Tile sizes"), llvm::cl::ZeroOrMore};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TILINGPASS
#endif // GEN_PASS_DEF_TILINGPASS

//===----------------------------------------------------------------------===//
// TilingSoftmaxPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TILINGSOFTMAXPASS
struct TilingSoftmaxPassOptions {
  bool distribute = true;
  ::llvm::ArrayRef<int64_t> tileSizes;
  std::string distributionLabel;
};
#undef GEN_PASS_DECL_TILINGSOFTMAXPASS
#endif // GEN_PASS_DECL_TILINGSOFTMAXPASS
#ifdef GEN_PASS_DEF_TILINGSOFTMAXPASS
namespace impl {

template <typename DerivedT>
class TilingSoftmaxPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TilingSoftmaxPassBase;

  TilingSoftmaxPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TilingSoftmaxPassBase(const TilingSoftmaxPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-tiling-softmax");
  }
  ::llvm::StringRef getArgument() const override { return "gml-tiling-softmax"; }

  ::llvm::StringRef getDescription() const override { return "Match, tile, and fuse softmax implementations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TilingSoftmaxPass");
  }
  ::llvm::StringRef getName() const override { return "TilingSoftmaxPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TilingSoftmaxPassBase<DerivedT>)

  TilingSoftmaxPassBase(const TilingSoftmaxPassOptions &options) : TilingSoftmaxPassBase() {
    distribute = options.distribute;
    tileSizes = options.tileSizes;
    distributionLabel = options.distributionLabel;
  }
protected:
  ::mlir::Pass::Option<bool> distribute{*this, "distribute", ::llvm::cl::desc("Generate gml_st.parallel or gml_st.for"), ::llvm::cl::init(true)};
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Right-aligned tile sizes. Do not tile possible remaining dimensions"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::Option<std::string> distributionLabel{*this, "distribution-label", ::llvm::cl::desc("Distribution label for generated gml_st.parallel")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TILINGSOFTMAXPASS
#endif // GEN_PASS_DEF_TILINGSOFTMAXPASS

//===----------------------------------------------------------------------===//
// TransformMapForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMMAPFORCPUPASS
struct TransformMapForCpuPassOptions {
  int64_t tileSize = 1;
};
#undef GEN_PASS_DECL_TRANSFORMMAPFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMMAPFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMMAPFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformMapForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformMapForCpuPassBase;

  TransformMapForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformMapForCpuPassBase(const TransformMapForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-cpu-transform-map");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-cpu-transform-map"; }

  ::llvm::StringRef getDescription() const override { return "Transform map ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformMapForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformMapForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformMapForCpuPassBase<DerivedT>)

  TransformMapForCpuPassBase(const TransformMapForCpuPassOptions &options) : TransformMapForCpuPassBase() {
    tileSize = options.tileSize;
  }
protected:
  ::mlir::Pass::Option<int64_t> tileSize{*this, "tile-size", ::llvm::cl::desc("Tile size for the innermost dimension of `linalg.map`"), ::llvm::cl::init(1)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMMAPFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMMAPFORCPUPASS

//===----------------------------------------------------------------------===//
// TransformMatmulForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMMATMULFORCPUPASS
struct TransformMatmulForCpuPassOptions {
  bool lowerToMmt4D = false;
  ::llvm::ArrayRef<int64_t> tileSizes;
};
#undef GEN_PASS_DECL_TRANSFORMMATMULFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMMATMULFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMMATMULFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformMatmulForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformMatmulForCpuPassBase;

  TransformMatmulForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformMatmulForCpuPassBase(const TransformMatmulForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-matmul"; }

  ::llvm::StringRef getDescription() const override { return "Transform matmul ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformMatmulForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformMatmulForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformMatmulForCpuPassBase<DerivedT>)

  TransformMatmulForCpuPassBase(const TransformMatmulForCpuPassOptions &options) : TransformMatmulForCpuPassBase() {
    lowerToMmt4D = options.lowerToMmt4D;
    tileSizes = options.tileSizes;
  }
protected:
  ::mlir::Pass::Option<bool> lowerToMmt4D{*this, "lower-to-mmt4d", ::llvm::cl::desc("If true, lower linalg.matmul into linalg.mmt4d"), ::llvm::cl::init(false)};
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Tile sizes for a `linalg.matmul`")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMMATMULFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMMATMULFORCPUPASS

//===----------------------------------------------------------------------===//
// TransformMatmulForTritonPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMMATMULFORTRITONPASS
struct TransformMatmulForTritonPassOptions {
  ::llvm::ArrayRef<int64_t> tileSizes;
  std::string distributionLabel;
};
#undef GEN_PASS_DECL_TRANSFORMMATMULFORTRITONPASS
#endif // GEN_PASS_DECL_TRANSFORMMATMULFORTRITONPASS
#ifdef GEN_PASS_DEF_TRANSFORMMATMULFORTRITONPASS
namespace impl {

template <typename DerivedT>
class TransformMatmulForTritonPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformMatmulForTritonPassBase;

  TransformMatmulForTritonPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformMatmulForTritonPassBase(const TransformMatmulForTritonPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-triton-transform-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "xla-triton-transform-matmul"; }

  ::llvm::StringRef getDescription() const override { return "Transform matmul ops for lowering to Triton"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformMatmulForTritonPass");
  }
  ::llvm::StringRef getName() const override { return "TransformMatmulForTritonPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformMatmulForTritonPassBase<DerivedT>)

  TransformMatmulForTritonPassBase(const TransformMatmulForTritonPassOptions &options) : TransformMatmulForTritonPassBase() {
    tileSizes = options.tileSizes;
    distributionLabel = options.distributionLabel;
  }
protected:
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Tile sizes for a `linalg.matmul`")};
  ::mlir::Pass::Option<std::string> distributionLabel{*this, "distribution-label", ::llvm::cl::desc("Distribution label for generated gml_st.parallel")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMMATMULFORTRITONPASS
#endif // GEN_PASS_DEF_TRANSFORMMATMULFORTRITONPASS

//===----------------------------------------------------------------------===//
// TransformReduceForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMREDUCEFORCPUPASS
struct TransformReduceForCpuPassOptions {
  int64_t vectorSize = 8;
  int64_t tileSize1D = 32;
  ::llvm::ArrayRef<int64_t> tileSizes2D;
};
#undef GEN_PASS_DECL_TRANSFORMREDUCEFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMREDUCEFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMREDUCEFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformReduceForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformReduceForCpuPassBase;

  TransformReduceForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformReduceForCpuPassBase(const TransformReduceForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-reduce");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-reduce"; }

  ::llvm::StringRef getDescription() const override { return "Transform reduce ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformReduceForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformReduceForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformReduceForCpuPassBase<DerivedT>)

  TransformReduceForCpuPassBase(const TransformReduceForCpuPassOptions &options) : TransformReduceForCpuPassBase() {
    vectorSize = options.vectorSize;
    tileSize1D = options.tileSize1D;
    tileSizes2D = options.tileSizes2D;
  }
protected:
  ::mlir::Pass::Option<int64_t> vectorSize{*this, "vector-size", ::llvm::cl::desc("Vector size for a 1D `linalg.reduce`"), ::llvm::cl::init(8)};
  ::mlir::Pass::Option<int64_t> tileSize1D{*this, "tile-size-1d", ::llvm::cl::desc("Tile size for a 1D `linalg.reduce`"), ::llvm::cl::init(32)};
  ::mlir::Pass::ListOption<int64_t> tileSizes2D{*this, "tile-sizes-2d", ::llvm::cl::desc("Tile sizes for a `linalg.reduce`. tileSizes[0] is the parallel dimension and tileSizes[1] is the reduction dimension.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMREDUCEFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMREDUCEFORCPUPASS

//===----------------------------------------------------------------------===//
// TransformReverseForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMREVERSEFORCPUPASS
struct TransformReverseForCpuPassOptions {
  int64_t vectorSize = 8;
};
#undef GEN_PASS_DECL_TRANSFORMREVERSEFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMREVERSEFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMREVERSEFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformReverseForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformReverseForCpuPassBase;

  TransformReverseForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformReverseForCpuPassBase(const TransformReverseForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-reverse");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-reverse"; }

  ::llvm::StringRef getDescription() const override { return "Transform reverse ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformReverseForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformReverseForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformReverseForCpuPassBase<DerivedT>)

  TransformReverseForCpuPassBase(const TransformReverseForCpuPassOptions &options) : TransformReverseForCpuPassBase() {
    vectorSize = options.vectorSize;
  }
protected:
  ::mlir::Pass::Option<int64_t> vectorSize{*this, "vector-size", ::llvm::cl::desc("Vector size for 'thlo.reverse`"), ::llvm::cl::init(8)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMREVERSEFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMREVERSEFORCPUPASS

//===----------------------------------------------------------------------===//
// TransformScatterForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMSCATTERFORCPUPASS
#undef GEN_PASS_DECL_TRANSFORMSCATTERFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMSCATTERFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMSCATTERFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformScatterForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformScatterForCpuPassBase;

  TransformScatterForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformScatterForCpuPassBase(const TransformScatterForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-scatter");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-scatter"; }

  ::llvm::StringRef getDescription() const override { return "Transform scatter ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformScatterForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformScatterForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformScatterForCpuPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMSCATTERFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMSCATTERFORCPUPASS

//===----------------------------------------------------------------------===//
// TransformSortForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMSORTFORCPUPASS
#undef GEN_PASS_DECL_TRANSFORMSORTFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMSORTFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMSORTFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformSortForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformSortForCpuPassBase;

  TransformSortForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformSortForCpuPassBase(const TransformSortForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-cpu-transform-sort");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-cpu-transform-sort"; }

  ::llvm::StringRef getDescription() const override { return "Transform sort ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformSortForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformSortForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformSortForCpuPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMSORTFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMSORTFORCPUPASS

//===----------------------------------------------------------------------===//
// TransformTransposeForCpuPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRANSFORMTRANSPOSEFORCPUPASS
struct TransformTransposeForCpuPassOptions {
  ::llvm::ArrayRef<int64_t> tileSizes;
};
#undef GEN_PASS_DECL_TRANSFORMTRANSPOSEFORCPUPASS
#endif // GEN_PASS_DECL_TRANSFORMTRANSPOSEFORCPUPASS
#ifdef GEN_PASS_DEF_TRANSFORMTRANSPOSEFORCPUPASS
namespace impl {

template <typename DerivedT>
class TransformTransposeForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformTransposeForCpuPassBase;

  TransformTransposeForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformTransposeForCpuPassBase(const TransformTransposeForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-cpu-transform-transpose");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-cpu-transform-transpose"; }

  ::llvm::StringRef getDescription() const override { return "Transform transpose ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformTransposeForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformTransposeForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformTransposeForCpuPassBase<DerivedT>)

  TransformTransposeForCpuPassBase(const TransformTransposeForCpuPassOptions &options) : TransformTransposeForCpuPassBase() {
    tileSizes = options.tileSizes;
  }
protected:
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Tile sizes for a `linalg.transpose`")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRANSFORMTRANSPOSEFORCPUPASS
#endif // GEN_PASS_DEF_TRANSFORMTRANSPOSEFORCPUPASS

//===----------------------------------------------------------------------===//
// VectorizeCopyPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VECTORIZECOPYPASS
#undef GEN_PASS_DECL_VECTORIZECOPYPASS
#endif // GEN_PASS_DECL_VECTORIZECOPYPASS
#ifdef GEN_PASS_DEF_VECTORIZECOPYPASS
namespace impl {

template <typename DerivedT>
class VectorizeCopyPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeCopyPassBase;

  VectorizeCopyPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeCopyPassBase(const VectorizeCopyPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vectorize-copy");
  }
  ::llvm::StringRef getArgument() const override { return "vectorize-copy"; }

  ::llvm::StringRef getDescription() const override { return "Pass to vectorize `memref.copy`."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeCopyPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeCopyPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeCopyPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_VECTORIZECOPYPASS
#endif // GEN_PASS_DEF_VECTORIZECOPYPASS

//===----------------------------------------------------------------------===//
// VectorizeForCPUPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VECTORIZEFORCPUPASS
#undef GEN_PASS_DECL_VECTORIZEFORCPUPASS
#endif // GEN_PASS_DECL_VECTORIZEFORCPUPASS
#ifdef GEN_PASS_DEF_VECTORIZEFORCPUPASS
namespace impl {

template <typename DerivedT>
class VectorizeForCPUPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeForCPUPassBase;

  VectorizeForCPUPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeForCPUPassBase(const VectorizeForCPUPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vectorize-for-cpu");
  }
  ::llvm::StringRef getArgument() const override { return "vectorize-for-cpu"; }

  ::llvm::StringRef getDescription() const override { return "Pass to vectorize gml_st.for loops that are tiled perfectly."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeForCPUPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeForCPUPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  registry.insert<::mlir::tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeForCPUPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_VECTORIZEFORCPUPASS
#endif // GEN_PASS_DEF_VECTORIZEFORCPUPASS

//===----------------------------------------------------------------------===//
// VectorizeForGPUPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VECTORIZEFORGPUPASS
struct VectorizeForGPUPassOptions {
  bool vectorizeGmlStOps = false;
  ::llvm::ArrayRef<std::string> distributionLabels;
};
#undef GEN_PASS_DECL_VECTORIZEFORGPUPASS
#endif // GEN_PASS_DECL_VECTORIZEFORGPUPASS
#ifdef GEN_PASS_DEF_VECTORIZEFORGPUPASS
namespace impl {

template <typename DerivedT>
class VectorizeForGPUPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeForGPUPassBase;

  VectorizeForGPUPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeForGPUPassBase(const VectorizeForGPUPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vectorize-for-gpu");
  }
  ::llvm::StringRef getArgument() const override { return "vectorize-for-gpu"; }

  ::llvm::StringRef getDescription() const override { return "Pass to vectorize compute ops and gml_st.loops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeForGPUPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeForGPUPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeForGPUPassBase<DerivedT>)

  VectorizeForGPUPassBase(const VectorizeForGPUPassOptions &options) : VectorizeForGPUPassBase() {
    vectorizeGmlStOps = options.vectorizeGmlStOps;
    distributionLabels = options.distributionLabels;
  }
protected:
  ::mlir::Pass::Option<bool> vectorizeGmlStOps{*this, "vectorize-gml-st-ops", ::llvm::cl::desc("If true, vectorizes GmlSt ops in addition to linalg ops"), ::llvm::cl::init(false)};
  ::mlir::Pass::ListOption<std::string> distributionLabels{*this, "included-distribution-labels", ::llvm::cl::desc("Distribution labels of gml_st.parallel ops where vectorization is allowed. Empty list signifies that vectorization is allowed within all loops."), llvm::cl::ZeroOrMore};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_VECTORIZEFORGPUPASS
#endif // GEN_PASS_DEF_VECTORIZEFORGPUPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// AddDebugInfoPass Registration
//===----------------------------------------------------------------------===//

inline void registerAddDebugInfoPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createAddDebugInfoPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerAddDebugInfoPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createAddDebugInfoPass();
  });
}

//===----------------------------------------------------------------------===//
// CollapseShapePass Registration
//===----------------------------------------------------------------------===//

inline void registerCollapseShapePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createCollapseShapePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerCollapseShapePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createCollapseShapePass();
  });
}

//===----------------------------------------------------------------------===//
// ComposeExtractInsertSlicePass Registration
//===----------------------------------------------------------------------===//

inline void registerComposeExtractInsertSlicePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createComposeExtractInsertSlicePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerComposeExtractInsertSlicePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createComposeExtractInsertSlicePass();
  });
}

//===----------------------------------------------------------------------===//
// FusionPass Registration
//===----------------------------------------------------------------------===//

inline void registerFusionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createFusionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFusionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createFusionPass();
  });
}

//===----------------------------------------------------------------------===//
// GmlStSimtfyPass Registration
//===----------------------------------------------------------------------===//

inline void registerGmlStSimtfyPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createGmlStSimtfyPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGmlStSimtfyPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createGmlStSimtfyPass();
  });
}

//===----------------------------------------------------------------------===//
// GmlStToGpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerGmlStToGpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createGmlStToGpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGmlStToGpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createGmlStToGpuPass();
  });
}

//===----------------------------------------------------------------------===//
// GmlStToScf Registration
//===----------------------------------------------------------------------===//

inline void registerGmlStToScf() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createGmlStToScfPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGmlStToScfPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createGmlStToScfPass();
  });
}

//===----------------------------------------------------------------------===//
// GreedyFusionPass Registration
//===----------------------------------------------------------------------===//

inline void registerGreedyFusionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createGreedyFusionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGreedyFusionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createGreedyFusionPass();
  });
}

//===----------------------------------------------------------------------===//
// RewriteVectorContractPass Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteVectorContractPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createRewriteVectorContractPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRewriteVectorContractPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createRewriteVectorContractPass();
  });
}

//===----------------------------------------------------------------------===//
// RewriteVectorMultiReductionPass Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteVectorMultiReductionPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createRewriteVectorMultiReductionPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRewriteVectorMultiReductionPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createRewriteVectorMultiReductionPass();
  });
}

//===----------------------------------------------------------------------===//
// RewriteVectorTransposePass Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteVectorTransposePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createRewriteVectorTransposePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRewriteVectorTransposePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createRewriteVectorTransposePass();
  });
}

//===----------------------------------------------------------------------===//
// ScalarizationPass Registration
//===----------------------------------------------------------------------===//

inline void registerScalarizationPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createScalarizationPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerScalarizationPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createScalarizationPass();
  });
}

//===----------------------------------------------------------------------===//
// SimplifyDeadCopyPass Registration
//===----------------------------------------------------------------------===//

inline void registerSimplifyDeadCopyPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createSimplifyDeadCopyPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSimplifyDeadCopyPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createSimplifyDeadCopyPass();
  });
}

//===----------------------------------------------------------------------===//
// TilingCwisePass Registration
//===----------------------------------------------------------------------===//

inline void registerTilingCwisePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTilingCwisePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTilingCwisePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTilingCwisePass();
  });
}

//===----------------------------------------------------------------------===//
// TilingGPUWarpPass Registration
//===----------------------------------------------------------------------===//

inline void registerTilingGPUWarpPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTilingGpuWarpPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTilingGPUWarpPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTilingGpuWarpPass();
  });
}

//===----------------------------------------------------------------------===//
// TilingPass Registration
//===----------------------------------------------------------------------===//

inline void registerTilingPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTilingPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTilingPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTilingPass();
  });
}

//===----------------------------------------------------------------------===//
// TilingSoftmaxPass Registration
//===----------------------------------------------------------------------===//

inline void registerTilingSoftmaxPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTilingSoftmaxPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTilingSoftmaxPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTilingSoftmaxPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformMapForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformMapForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTransformMapForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformMapForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createTransformMapForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformMatmulForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformMatmulForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformMatmulForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformMatmulForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformMatmulForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformMatmulForTritonPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformMatmulForTritonPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformMatmulForTritonPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformMatmulForTritonPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformMatmulForTritonPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformReduceForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformReduceForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformReduceForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformReduceForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformReduceForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformReverseForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformReverseForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformReverseForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformReverseForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformReverseForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformScatterForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformScatterForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformScatterForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformScatterForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformScatterForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformSortForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformSortForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformSortForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformSortForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformSortForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// TransformTransposeForCpuPass Registration
//===----------------------------------------------------------------------===//

inline void registerTransformTransposeForCpuPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformTransposeForCpuPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTransformTransposeForCpuPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTransformTransposeForCpuPass();
  });
}

//===----------------------------------------------------------------------===//
// VectorizeCopyPass Registration
//===----------------------------------------------------------------------===//

inline void registerVectorizeCopyPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createVectorizeCopyPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVectorizeCopyPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createVectorizeCopyPass();
  });
}

//===----------------------------------------------------------------------===//
// VectorizeForCPUPass Registration
//===----------------------------------------------------------------------===//

inline void registerVectorizeForCPUPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createVectorizeForCPUPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVectorizeForCPUPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createVectorizeForCPUPass();
  });
}

//===----------------------------------------------------------------------===//
// VectorizeForGPUPass Registration
//===----------------------------------------------------------------------===//

inline void registerVectorizeForGPUPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createVectorizeForGPUPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVectorizeForGPUPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return ::mlir::gml_st::createVectorizeForGPUPass();
  });
}

//===----------------------------------------------------------------------===//
// GmlSt Registration
//===----------------------------------------------------------------------===//

inline void registerGmlStPasses() {
  registerAddDebugInfoPass();
  registerCollapseShapePass();
  registerComposeExtractInsertSlicePass();
  registerFusionPass();
  registerGmlStSimtfyPass();
  registerGmlStToGpuPass();
  registerGmlStToScf();
  registerGreedyFusionPass();
  registerRewriteVectorContractPass();
  registerRewriteVectorMultiReductionPass();
  registerRewriteVectorTransposePass();
  registerScalarizationPass();
  registerSimplifyDeadCopyPass();
  registerTilingCwisePass();
  registerTilingGPUWarpPass();
  registerTilingPass();
  registerTilingSoftmaxPass();
  registerTransformMapForCpuPass();
  registerTransformMatmulForCpuPass();
  registerTransformMatmulForTritonPass();
  registerTransformReduceForCpuPass();
  registerTransformReverseForCpuPass();
  registerTransformScatterForCpuPass();
  registerTransformSortForCpuPass();
  registerTransformTransposeForCpuPass();
  registerVectorizeCopyPass();
  registerVectorizeForCPUPass();
  registerVectorizeForGPUPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class AddDebugInfoPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = AddDebugInfoPassBase;

  AddDebugInfoPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  AddDebugInfoPassBase(const AddDebugInfoPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("add-debug-info");
  }
  ::llvm::StringRef getArgument() const override { return "add-debug-info"; }

  ::llvm::StringRef getDescription() const override { return "Add debug info for the whole module"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("AddDebugInfoPass");
  }
  ::llvm::StringRef getName() const override { return "AddDebugInfoPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::LLVM::LLVMDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(AddDebugInfoPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class CollapseShapePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = CollapseShapePassBase;

  CollapseShapePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  CollapseShapePassBase(const CollapseShapePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-collapse-shape");
  }
  ::llvm::StringRef getArgument() const override { return "gml-collapse-shape"; }

  ::llvm::StringRef getDescription() const override { return "Collapse dimensions of bcasts, reductions, and cwise ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("CollapseShapePass");
  }
  ::llvm::StringRef getName() const override { return "CollapseShapePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(CollapseShapePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> retainTrailingDims{*this, "retain-trailing-dims", ::llvm::cl::desc("Number of trailing dimensions that will not be collapsed."), ::llvm::cl::init(0)};
};

template <typename DerivedT>
class ComposeExtractInsertSlicePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ComposeExtractInsertSlicePassBase;

  ComposeExtractInsertSlicePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ComposeExtractInsertSlicePassBase(const ComposeExtractInsertSlicePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-compose-extract-insert-slice");
  }
  ::llvm::StringRef getArgument() const override { return "gml-compose-extract-insert-slice"; }

  ::llvm::StringRef getDescription() const override { return "Compose tensor.extract_slice/insert_slice ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ComposeExtractInsertSlicePass");
  }
  ::llvm::StringRef getName() const override { return "ComposeExtractInsertSlicePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ComposeExtractInsertSlicePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FusionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = FusionPassBase;

  FusionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  FusionPassBase(const FusionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-fusion");
  }
  ::llvm::StringRef getArgument() const override { return "gml-fusion"; }

  ::llvm::StringRef getDescription() const override { return "Fuse producers in into `gml_st.materialize` operations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FusionPass");
  }
  ::llvm::StringRef getName() const override { return "FusionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FusionPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> producerLabel{*this, "producer-label", ::llvm::cl::desc("Producer label.")};
  ::mlir::Pass::Option<std::string> consumerLabel{*this, "consumer-label", ::llvm::cl::desc("Consumer label.")};
};

template <typename DerivedT>
class GmlStSimtfyPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = GmlStSimtfyPassBase;

  GmlStSimtfyPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  GmlStSimtfyPassBase(const GmlStSimtfyPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-simtfy");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-simtfy"; }

  ::llvm::StringRef getDescription() const override { return "Lower nested `gml_st.parallel` to `gpu.launch`"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GmlStSimtfyPass");
  }
  ::llvm::StringRef getName() const override { return "GmlStSimtfyPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::AffineDialect>();

  registry.insert<::mlir::arith::ArithDialect>();

  registry.insert<::mlir::gpu::GPUDialect>();

  registry.insert<::mlir::scf::SCFDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GmlStSimtfyPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> blockDistributionLabel{*this, "block-distribution-label", ::llvm::cl::desc("Direct children of `gml_st.parallel` loops with this distribution type are distributed over blocks."), ::llvm::cl::init("block")};
};

template <typename DerivedT>
class GmlStToGpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = GmlStToGpuPassBase;

  GmlStToGpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  GmlStToGpuPassBase(const GmlStToGpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-to-gpu");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-to-gpu"; }

  ::llvm::StringRef getDescription() const override { return "Lower nested `gml_st.parallel` to `gpu.launch`"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GmlStToGpuPass");
  }
  ::llvm::StringRef getName() const override { return "GmlStToGpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::gpu::GPUDialect>();

  registry.insert<::mlir::vector::VectorDialect>();

  registry.insert<::mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GmlStToGpuPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> warpDistributionLabel{*this, "warp-distribution-label", ::llvm::cl::desc("Direct children of `gml_st.parallel` loops with this distribution type are distributed over warps."), ::llvm::cl::init("warp")};
};

template <typename DerivedT>
class GmlStToScfBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = GmlStToScfBase;

  GmlStToScfBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  GmlStToScfBase(const GmlStToScfBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lower `gml_st.loop` to SCF loops and parallel loops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GmlStToScf");
  }
  ::llvm::StringRef getName() const override { return "GmlStToScf"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::scf::SCFDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GmlStToScfBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GreedyFusionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = GreedyFusionPassBase;

  GreedyFusionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  GreedyFusionPassBase(const GreedyFusionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-greedy-fusion");
  }
  ::llvm::StringRef getArgument() const override { return "gml-greedy-fusion"; }

  ::llvm::StringRef getDescription() const override { return "Pass to tile the root operation and to greedily fuse producers into it."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GreedyFusionPass");
  }
  ::llvm::StringRef getName() const override { return "GreedyFusionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GreedyFusionPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> distribute{*this, "distribute", ::llvm::cl::desc("Generate gml_st.parallel or gml_st.for"), ::llvm::cl::init(true)};
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Tile sizes"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::Option<std::string> distributionLabel{*this, "distribution-label", ::llvm::cl::desc("Distribution label for generated gml_st.parallel")};
};

template <typename DerivedT>
class RewriteVectorContractPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteVectorContractPassBase;

  RewriteVectorContractPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteVectorContractPassBase(const RewriteVectorContractPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("rewrite-vector-contract");
  }
  ::llvm::StringRef getArgument() const override { return "rewrite-vector-contract"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite vector.contract."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteVectorContractPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteVectorContractPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteVectorContractPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RewriteVectorMultiReductionPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteVectorMultiReductionPassBase;

  RewriteVectorMultiReductionPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteVectorMultiReductionPassBase(const RewriteVectorMultiReductionPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("rewrite-vector-multi-reduction");
  }
  ::llvm::StringRef getArgument() const override { return "rewrite-vector-multi-reduction"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite vector.multi_reduction."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteVectorMultiReductionPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteVectorMultiReductionPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteVectorMultiReductionPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RewriteVectorTransposePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteVectorTransposePassBase;

  RewriteVectorTransposePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteVectorTransposePassBase(const RewriteVectorTransposePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("rewrite-vector-transpose");
  }
  ::llvm::StringRef getArgument() const override { return "rewrite-vector-transpose"; }

  ::llvm::StringRef getDescription() const override { return "Pass to rewrite vector.transpose."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteVectorTransposePass");
  }
  ::llvm::StringRef getName() const override { return "RewriteVectorTransposePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::LLVM::LLVMDialect>();

  registry.insert<::mlir::vector::VectorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteVectorTransposePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ScalarizationPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ScalarizationPassBase;

  ScalarizationPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ScalarizationPassBase(const ScalarizationPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("scalarize");
  }
  ::llvm::StringRef getArgument() const override { return "scalarize"; }

  ::llvm::StringRef getDescription() const override { return "Converts ops on tensors with 1 element to scalar ops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ScalarizationPass");
  }
  ::llvm::StringRef getName() const override { return "ScalarizationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<arith::ArithDialect>();

  registry.insert<gml_st::GmlStDialect>();

  registry.insert<scf::SCFDialect>();

  registry.insert<tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ScalarizationPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SimplifyDeadCopyPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SimplifyDeadCopyPassBase;

  SimplifyDeadCopyPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyDeadCopyPassBase(const SimplifyDeadCopyPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("simplify-dead-copy");
  }
  ::llvm::StringRef getArgument() const override { return "simplify-dead-copy"; }

  ::llvm::StringRef getDescription() const override { return "Pass to simplify dead `memref.copy`."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyDeadCopyPass");
  }
  ::llvm::StringRef getName() const override { return "SimplifyDeadCopyPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  registry.insert<::mlir::memref::MemRefDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyDeadCopyPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TilingCwisePassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TilingCwisePassBase;

  TilingCwisePassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TilingCwisePassBase(const TilingCwisePassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-tiling-cwise");
  }
  ::llvm::StringRef getArgument() const override { return "gml-tiling-cwise"; }

  ::llvm::StringRef getDescription() const override { return "Tile and fuse all cwise ops"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TilingCwisePass");
  }
  ::llvm::StringRef getName() const override { return "TilingCwisePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TilingCwisePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> distribute_{*this, "distribute", ::llvm::cl::desc("Generate gml_st.parallel or gml_st.for"), ::llvm::cl::init(true)};
  ::mlir::Pass::ListOption<int64_t> tileSizes_{*this, "tile-sizes", ::llvm::cl::desc("Right-aligned tile sizes. Do not tile possible remaining dimensions"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::Option<std::string> distributionLabel_{*this, "distribution-label", ::llvm::cl::desc("Distribution label for generated gml_st.parallel")};
};

template <typename DerivedT>
class TilingGPUWarpPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TilingGPUWarpPassBase;

  TilingGPUWarpPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TilingGPUWarpPassBase(const TilingGPUWarpPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-tiling-gpu-warp");
  }
  ::llvm::StringRef getArgument() const override { return "gml-tiling-gpu-warp"; }

  ::llvm::StringRef getDescription() const override { return "Tile warp-level ops for GPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TilingGPUWarpPass");
  }
  ::llvm::StringRef getName() const override { return "TilingGPUWarpPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::gml_st::GmlStDialect>();

  registry.insert<::mlir::arith::ArithDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TilingGPUWarpPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TilingPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TilingPassBase;

  TilingPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TilingPassBase(const TilingPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-tiling");
  }
  ::llvm::StringRef getArgument() const override { return "gml-tiling"; }

  ::llvm::StringRef getDescription() const override { return "Tile operations using TilingInterface to produce gml_st.for"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TilingPass");
  }
  ::llvm::StringRef getName() const override { return "TilingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TilingPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> opName{*this, "op-name", ::llvm::cl::desc("Operation with this name is the anchor to latch on.")};
  ::mlir::Pass::Option<std::string> opLabel{*this, "op-label", ::llvm::cl::desc("Operation with this label is the anchor to latch on.")};
  ::mlir::Pass::Option<bool> distribute{*this, "distribute", ::llvm::cl::desc("Generate gml_st.parallel or gml_st.for"), ::llvm::cl::init(true)};
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Tile sizes"), llvm::cl::ZeroOrMore};
};

template <typename DerivedT>
class TilingSoftmaxPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TilingSoftmaxPassBase;

  TilingSoftmaxPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TilingSoftmaxPassBase(const TilingSoftmaxPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-tiling-softmax");
  }
  ::llvm::StringRef getArgument() const override { return "gml-tiling-softmax"; }

  ::llvm::StringRef getDescription() const override { return "Match, tile, and fuse softmax implementations"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TilingSoftmaxPass");
  }
  ::llvm::StringRef getName() const override { return "TilingSoftmaxPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TilingSoftmaxPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> distribute{*this, "distribute", ::llvm::cl::desc("Generate gml_st.parallel or gml_st.for"), ::llvm::cl::init(true)};
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Right-aligned tile sizes. Do not tile possible remaining dimensions"), llvm::cl::ZeroOrMore};
  ::mlir::Pass::Option<std::string> distributionLabel{*this, "distribution-label", ::llvm::cl::desc("Distribution label for generated gml_st.parallel")};
};

template <typename DerivedT>
class TransformMapForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformMapForCpuPassBase;

  TransformMapForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformMapForCpuPassBase(const TransformMapForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-cpu-transform-map");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-cpu-transform-map"; }

  ::llvm::StringRef getDescription() const override { return "Transform map ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformMapForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformMapForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformMapForCpuPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> tileSize{*this, "tile-size", ::llvm::cl::desc("Tile size for the innermost dimension of `linalg.map`"), ::llvm::cl::init(1)};
};

template <typename DerivedT>
class TransformMatmulForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformMatmulForCpuPassBase;

  TransformMatmulForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformMatmulForCpuPassBase(const TransformMatmulForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-matmul"; }

  ::llvm::StringRef getDescription() const override { return "Transform matmul ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformMatmulForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformMatmulForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformMatmulForCpuPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> lowerToMmt4D{*this, "lower-to-mmt4d", ::llvm::cl::desc("If true, lower linalg.matmul into linalg.mmt4d"), ::llvm::cl::init(false)};
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Tile sizes for a `linalg.matmul`")};
};

template <typename DerivedT>
class TransformMatmulForTritonPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformMatmulForTritonPassBase;

  TransformMatmulForTritonPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformMatmulForTritonPassBase(const TransformMatmulForTritonPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-triton-transform-matmul");
  }
  ::llvm::StringRef getArgument() const override { return "xla-triton-transform-matmul"; }

  ::llvm::StringRef getDescription() const override { return "Transform matmul ops for lowering to Triton"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformMatmulForTritonPass");
  }
  ::llvm::StringRef getName() const override { return "TransformMatmulForTritonPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformMatmulForTritonPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Tile sizes for a `linalg.matmul`")};
  ::mlir::Pass::Option<std::string> distributionLabel{*this, "distribution-label", ::llvm::cl::desc("Distribution label for generated gml_st.parallel")};
};

template <typename DerivedT>
class TransformReduceForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformReduceForCpuPassBase;

  TransformReduceForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformReduceForCpuPassBase(const TransformReduceForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-reduce");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-reduce"; }

  ::llvm::StringRef getDescription() const override { return "Transform reduce ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformReduceForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformReduceForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformReduceForCpuPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> vectorSize{*this, "vector-size", ::llvm::cl::desc("Vector size for a 1D `linalg.reduce`"), ::llvm::cl::init(8)};
  ::mlir::Pass::Option<int64_t> tileSize1D{*this, "tile-size-1d", ::llvm::cl::desc("Tile size for a 1D `linalg.reduce`"), ::llvm::cl::init(32)};
  ::mlir::Pass::ListOption<int64_t> tileSizes2D{*this, "tile-sizes-2d", ::llvm::cl::desc("Tile sizes for a `linalg.reduce`. tileSizes[0] is the parallel dimension and tileSizes[1] is the reduction dimension.")};
};

template <typename DerivedT>
class TransformReverseForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformReverseForCpuPassBase;

  TransformReverseForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformReverseForCpuPassBase(const TransformReverseForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-reverse");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-reverse"; }

  ::llvm::StringRef getDescription() const override { return "Transform reverse ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformReverseForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformReverseForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformReverseForCpuPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<int64_t> vectorSize{*this, "vector-size", ::llvm::cl::desc("Vector size for 'thlo.reverse`"), ::llvm::cl::init(8)};
};

template <typename DerivedT>
class TransformScatterForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformScatterForCpuPassBase;

  TransformScatterForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformScatterForCpuPassBase(const TransformScatterForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-cpu-transform-scatter");
  }
  ::llvm::StringRef getArgument() const override { return "xla-cpu-transform-scatter"; }

  ::llvm::StringRef getDescription() const override { return "Transform scatter ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformScatterForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformScatterForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformScatterForCpuPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TransformSortForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformSortForCpuPassBase;

  TransformSortForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformSortForCpuPassBase(const TransformSortForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-cpu-transform-sort");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-cpu-transform-sort"; }

  ::llvm::StringRef getDescription() const override { return "Transform sort ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformSortForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformSortForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformSortForCpuPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TransformTransposeForCpuPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = TransformTransposeForCpuPassBase;

  TransformTransposeForCpuPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  TransformTransposeForCpuPassBase(const TransformTransposeForCpuPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("gml-st-cpu-transform-transpose");
  }
  ::llvm::StringRef getArgument() const override { return "gml-st-cpu-transform-transpose"; }

  ::llvm::StringRef getDescription() const override { return "Transform transpose ops for running on CPU"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TransformTransposeForCpuPass");
  }
  ::llvm::StringRef getName() const override { return "TransformTransposeForCpuPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TransformTransposeForCpuPassBase<DerivedT>)

protected:
  ::mlir::Pass::ListOption<int64_t> tileSizes{*this, "tile-sizes", ::llvm::cl::desc("Tile sizes for a `linalg.transpose`")};
};

template <typename DerivedT>
class VectorizeCopyPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeCopyPassBase;

  VectorizeCopyPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeCopyPassBase(const VectorizeCopyPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vectorize-copy");
  }
  ::llvm::StringRef getArgument() const override { return "vectorize-copy"; }

  ::llvm::StringRef getDescription() const override { return "Pass to vectorize `memref.copy`."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeCopyPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeCopyPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeCopyPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class VectorizeForCPUPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeForCPUPassBase;

  VectorizeForCPUPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeForCPUPassBase(const VectorizeForCPUPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vectorize-for-cpu");
  }
  ::llvm::StringRef getArgument() const override { return "vectorize-for-cpu"; }

  ::llvm::StringRef getDescription() const override { return "Pass to vectorize gml_st.for loops that are tiled perfectly."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeForCPUPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeForCPUPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  registry.insert<::mlir::tensor::TensorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeForCPUPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class VectorizeForGPUPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeForGPUPassBase;

  VectorizeForGPUPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeForGPUPassBase(const VectorizeForGPUPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("vectorize-for-gpu");
  }
  ::llvm::StringRef getArgument() const override { return "vectorize-for-gpu"; }

  ::llvm::StringRef getDescription() const override { return "Pass to vectorize compute ops and gml_st.loops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeForGPUPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeForGPUPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  registry.insert<::mlir::vector::VectorDialect>();

  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeForGPUPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> vectorizeGmlStOps{*this, "vectorize-gml-st-ops", ::llvm::cl::desc("If true, vectorizes GmlSt ops in addition to linalg ops"), ::llvm::cl::init(false)};
  ::mlir::Pass::ListOption<std::string> distributionLabels{*this, "included-distribution-labels", ::llvm::cl::desc("Distribution labels of gml_st.parallel ops where vectorization is allowed. Empty list signifies that vectorization is allowed within all loops."), llvm::cl::ZeroOrMore};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
