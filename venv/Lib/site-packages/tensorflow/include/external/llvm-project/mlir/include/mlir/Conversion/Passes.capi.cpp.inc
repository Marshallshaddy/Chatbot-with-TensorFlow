/* Autogenerated by mlir-tblgen; don't manually edit. */
//===----------------------------------------------------------------------===//
// Conversion Group Registration
//===----------------------------------------------------------------------===//

void mlirRegisterConversionPasses(void) {
  registerConversionPasses();
}

MlirPass mlirCreateConversionArithToLLVMConversionPass(void) {
  return wrap(createArithToLLVMConversionPass().release());
}
void mlirRegisterConversionArithToLLVMConversionPass(void) {
  registerArithToLLVMConversionPass();
}


MlirPass mlirCreateConversionConvertAMDGPUToROCDL(void) {
  return wrap(mlir::createConvertAMDGPUToROCDLPass().release());
}
void mlirRegisterConversionConvertAMDGPUToROCDL(void) {
  registerConvertAMDGPUToROCDL();
}


MlirPass mlirCreateConversionConvertAffineForToGPU(void) {
  return wrap(mlir::createAffineForToGPUPass().release());
}
void mlirRegisterConversionConvertAffineForToGPU(void) {
  registerConvertAffineForToGPU();
}


MlirPass mlirCreateConversionConvertAffineToStandard(void) {
  return wrap(mlir::createLowerAffinePass().release());
}
void mlirRegisterConversionConvertAffineToStandard(void) {
  registerConvertAffineToStandard();
}


MlirPass mlirCreateConversionConvertArithToSPIRV(void) {
  return wrap(mlir::arith::createConvertArithToSPIRVPass().release());
}
void mlirRegisterConversionConvertArithToSPIRV(void) {
  registerConvertArithToSPIRV();
}


MlirPass mlirCreateConversionConvertArmNeon2dToIntr(void) {
  return wrap(mlir::createConvertArmNeon2dToIntrPass().release());
}
void mlirRegisterConversionConvertArmNeon2dToIntr(void) {
  registerConvertArmNeon2dToIntr();
}


MlirPass mlirCreateConversionConvertAsyncToLLVM(void) {
  return wrap(mlir::createConvertAsyncToLLVMPass().release());
}
void mlirRegisterConversionConvertAsyncToLLVM(void) {
  registerConvertAsyncToLLVM();
}


MlirPass mlirCreateConversionConvertBufferizationToMemRef(void) {
  return wrap(mlir::createBufferizationToMemRefPass().release());
}
void mlirRegisterConversionConvertBufferizationToMemRef(void) {
  registerConvertBufferizationToMemRef();
}


MlirPass mlirCreateConversionConvertComplexToLLVM(void) {
  return wrap(mlir::createConvertComplexToLLVMPass().release());
}
void mlirRegisterConversionConvertComplexToLLVM(void) {
  registerConvertComplexToLLVM();
}


MlirPass mlirCreateConversionConvertComplexToLibm(void) {
  return wrap(mlir::createConvertComplexToLibmPass().release());
}
void mlirRegisterConversionConvertComplexToLibm(void) {
  registerConvertComplexToLibm();
}


MlirPass mlirCreateConversionConvertComplexToStandard(void) {
  return wrap(mlir::createConvertComplexToStandardPass().release());
}
void mlirRegisterConversionConvertComplexToStandard(void) {
  registerConvertComplexToStandard();
}


MlirPass mlirCreateConversionConvertControlFlowToLLVM(void) {
  return wrap(mlir::cf::createConvertControlFlowToLLVMPass().release());
}
void mlirRegisterConversionConvertControlFlowToLLVM(void) {
  registerConvertControlFlowToLLVM();
}


MlirPass mlirCreateConversionConvertControlFlowToSPIRV(void) {
  return wrap(mlir::createConvertControlFlowToSPIRVPass().release());
}
void mlirRegisterConversionConvertControlFlowToSPIRV(void) {
  registerConvertControlFlowToSPIRV();
}


MlirPass mlirCreateConversionConvertFuncToLLVM(void) {
  return wrap(mlir::createConvertFuncToLLVMPass().release());
}
void mlirRegisterConversionConvertFuncToLLVM(void) {
  registerConvertFuncToLLVM();
}


MlirPass mlirCreateConversionConvertFuncToSPIRV(void) {
  return wrap(mlir::createConvertFuncToSPIRVPass().release());
}
void mlirRegisterConversionConvertFuncToSPIRV(void) {
  registerConvertFuncToSPIRV();
}


MlirPass mlirCreateConversionConvertGPUToSPIRV(void) {
  return wrap(mlir::createConvertGPUToSPIRVPass().release());
}
void mlirRegisterConversionConvertGPUToSPIRV(void) {
  registerConvertGPUToSPIRV();
}


MlirPass mlirCreateConversionConvertGpuLaunchFuncToVulkanLaunchFunc(void) {
  return wrap(mlir::createConvertGpuLaunchFuncToVulkanLaunchFuncPass().release());
}
void mlirRegisterConversionConvertGpuLaunchFuncToVulkanLaunchFunc(void) {
  registerConvertGpuLaunchFuncToVulkanLaunchFunc();
}


MlirPass mlirCreateConversionConvertGpuOpsToNVVMOps(void) {
  return wrap(mlir::createLowerGpuOpsToNVVMOpsPass().release());
}
void mlirRegisterConversionConvertGpuOpsToNVVMOps(void) {
  registerConvertGpuOpsToNVVMOps();
}


MlirPass mlirCreateConversionConvertGpuOpsToROCDLOps(void) {
  return wrap(mlir::createLowerGpuOpsToROCDLOpsPass().release());
}
void mlirRegisterConversionConvertGpuOpsToROCDLOps(void) {
  registerConvertGpuOpsToROCDLOps();
}


MlirPass mlirCreateConversionConvertIndexToLLVMPass(void) {
  return wrap(createConvertIndexToLLVMPass().release());
}
void mlirRegisterConversionConvertIndexToLLVMPass(void) {
  registerConvertIndexToLLVMPass();
}


MlirPass mlirCreateConversionConvertLinalgToLLVM(void) {
  return wrap(mlir::createConvertLinalgToLLVMPass().release());
}
void mlirRegisterConversionConvertLinalgToLLVM(void) {
  registerConvertLinalgToLLVM();
}


MlirPass mlirCreateConversionConvertLinalgToStandard(void) {
  return wrap(mlir::createConvertLinalgToStandardPass().release());
}
void mlirRegisterConversionConvertLinalgToStandard(void) {
  registerConvertLinalgToStandard();
}


MlirPass mlirCreateConversionConvertMathToFuncs(void) {
  return wrap(createConvertMathToFuncs().release());
}
void mlirRegisterConversionConvertMathToFuncs(void) {
  registerConvertMathToFuncs();
}


MlirPass mlirCreateConversionConvertMathToLLVM(void) {
  return wrap(mlir::createConvertMathToLLVMPass().release());
}
void mlirRegisterConversionConvertMathToLLVM(void) {
  registerConvertMathToLLVM();
}


MlirPass mlirCreateConversionConvertMathToLibm(void) {
  return wrap(mlir::createConvertMathToLibmPass().release());
}
void mlirRegisterConversionConvertMathToLibm(void) {
  registerConvertMathToLibm();
}


MlirPass mlirCreateConversionConvertMathToSPIRV(void) {
  return wrap(mlir::createConvertMathToSPIRVPass().release());
}
void mlirRegisterConversionConvertMathToSPIRV(void) {
  registerConvertMathToSPIRV();
}


MlirPass mlirCreateConversionConvertMemRefToSPIRV(void) {
  return wrap(mlir::createConvertMemRefToSPIRVPass().release());
}
void mlirRegisterConversionConvertMemRefToSPIRV(void) {
  registerConvertMemRefToSPIRV();
}


MlirPass mlirCreateConversionConvertNVGPUToNVVM(void) {
  return wrap(mlir::createConvertNVGPUToNVVMPass().release());
}
void mlirRegisterConversionConvertNVGPUToNVVM(void) {
  registerConvertNVGPUToNVVM();
}


MlirPass mlirCreateConversionConvertOpenACCToLLVM(void) {
  return wrap(mlir::createConvertOpenACCToLLVMPass().release());
}
void mlirRegisterConversionConvertOpenACCToLLVM(void) {
  registerConvertOpenACCToLLVM();
}


MlirPass mlirCreateConversionConvertOpenACCToSCF(void) {
  return wrap(mlir::createConvertOpenACCToSCFPass().release());
}
void mlirRegisterConversionConvertOpenACCToSCF(void) {
  registerConvertOpenACCToSCF();
}


MlirPass mlirCreateConversionConvertOpenMPToLLVM(void) {
  return wrap(mlir::createConvertOpenMPToLLVMPass().release());
}
void mlirRegisterConversionConvertOpenMPToLLVM(void) {
  registerConvertOpenMPToLLVM();
}


MlirPass mlirCreateConversionConvertPDLToPDLInterp(void) {
  return wrap(mlir::createPDLToPDLInterpPass().release());
}
void mlirRegisterConversionConvertPDLToPDLInterp(void) {
  registerConvertPDLToPDLInterp();
}


MlirPass mlirCreateConversionConvertParallelLoopToGpu(void) {
  return wrap(mlir::createParallelLoopToGpuPass().release());
}
void mlirRegisterConversionConvertParallelLoopToGpu(void) {
  registerConvertParallelLoopToGpu();
}


MlirPass mlirCreateConversionConvertSCFToOpenMP(void) {
  return wrap(mlir::createConvertSCFToOpenMPPass().release());
}
void mlirRegisterConversionConvertSCFToOpenMP(void) {
  registerConvertSCFToOpenMP();
}


MlirPass mlirCreateConversionConvertSPIRVToLLVM(void) {
  return wrap(mlir::createConvertSPIRVToLLVMPass().release());
}
void mlirRegisterConversionConvertSPIRVToLLVM(void) {
  registerConvertSPIRVToLLVM();
}


MlirPass mlirCreateConversionConvertShapeConstraints(void) {
  return wrap(mlir::createConvertShapeConstraintsPass().release());
}
void mlirRegisterConversionConvertShapeConstraints(void) {
  registerConvertShapeConstraints();
}


MlirPass mlirCreateConversionConvertShapeToStandard(void) {
  return wrap(mlir::createConvertShapeToStandardPass().release());
}
void mlirRegisterConversionConvertShapeToStandard(void) {
  registerConvertShapeToStandard();
}


MlirPass mlirCreateConversionConvertTensorToLinalg(void) {
  return wrap(mlir::createConvertTensorToLinalgPass().release());
}
void mlirRegisterConversionConvertTensorToLinalg(void) {
  registerConvertTensorToLinalg();
}


MlirPass mlirCreateConversionConvertTensorToSPIRV(void) {
  return wrap(mlir::createConvertTensorToSPIRVPass().release());
}
void mlirRegisterConversionConvertTensorToSPIRV(void) {
  registerConvertTensorToSPIRV();
}


MlirPass mlirCreateConversionConvertVectorToGPU(void) {
  return wrap(mlir::createConvertVectorToGPUPass().release());
}
void mlirRegisterConversionConvertVectorToGPU(void) {
  registerConvertVectorToGPU();
}


MlirPass mlirCreateConversionConvertVectorToLLVM(void) {
  return wrap(mlir::createConvertVectorToLLVMPass().release());
}
void mlirRegisterConversionConvertVectorToLLVM(void) {
  registerConvertVectorToLLVM();
}


MlirPass mlirCreateConversionConvertVectorToSCF(void) {
  return wrap(mlir::createConvertVectorToSCFPass().release());
}
void mlirRegisterConversionConvertVectorToSCF(void) {
  registerConvertVectorToSCF();
}


MlirPass mlirCreateConversionConvertVectorToSPIRV(void) {
  return wrap(mlir::createConvertVectorToSPIRVPass().release());
}
void mlirRegisterConversionConvertVectorToSPIRV(void) {
  registerConvertVectorToSPIRV();
}


MlirPass mlirCreateConversionConvertVulkanLaunchFuncToVulkanCalls(void) {
  return wrap(mlir::createConvertVulkanLaunchFuncToVulkanCallsPass().release());
}
void mlirRegisterConversionConvertVulkanLaunchFuncToVulkanCalls(void) {
  registerConvertVulkanLaunchFuncToVulkanCalls();
}


MlirPass mlirCreateConversionFinalizeMemRefToLLVMConversionPass(void) {
  return wrap(createFinalizeMemRefToLLVMConversionPass().release());
}
void mlirRegisterConversionFinalizeMemRefToLLVMConversionPass(void) {
  registerFinalizeMemRefToLLVMConversionPass();
}


MlirPass mlirCreateConversionGpuToLLVMConversionPass(void) {
  return wrap(mlir::createGpuToLLVMConversionPass().release());
}
void mlirRegisterConversionGpuToLLVMConversionPass(void) {
  registerGpuToLLVMConversionPass();
}


MlirPass mlirCreateConversionLowerHostCodeToLLVM(void) {
  return wrap(mlir::createLowerHostCodeToLLVMPass().release());
}
void mlirRegisterConversionLowerHostCodeToLLVM(void) {
  registerLowerHostCodeToLLVM();
}


MlirPass mlirCreateConversionMapMemRefStorageClass(void) {
  return wrap(mlir::createMapMemRefStorageClassPass().release());
}
void mlirRegisterConversionMapMemRefStorageClass(void) {
  registerMapMemRefStorageClass();
}


MlirPass mlirCreateConversionReconcileUnrealizedCasts(void) {
  return wrap(mlir::createReconcileUnrealizedCastsPass().release());
}
void mlirRegisterConversionReconcileUnrealizedCasts(void) {
  registerReconcileUnrealizedCasts();
}


MlirPass mlirCreateConversionSCFToControlFlow(void) {
  return wrap(mlir::createConvertSCFToCFPass().release());
}
void mlirRegisterConversionSCFToControlFlow(void) {
  registerSCFToControlFlow();
}


MlirPass mlirCreateConversionSCFToSPIRV(void) {
  return wrap(mlir::createConvertSCFToSPIRVPass().release());
}
void mlirRegisterConversionSCFToSPIRV(void) {
  registerSCFToSPIRV();
}


MlirPass mlirCreateConversionTosaToArith(void) {
  return wrap(tosa::createTosaToArith().release());
}
void mlirRegisterConversionTosaToArith(void) {
  registerTosaToArith();
}


MlirPass mlirCreateConversionTosaToLinalg(void) {
  return wrap(tosa::createTosaToLinalg().release());
}
void mlirRegisterConversionTosaToLinalg(void) {
  registerTosaToLinalg();
}


MlirPass mlirCreateConversionTosaToLinalgNamed(void) {
  return wrap(tosa::createTosaToLinalgNamed().release());
}
void mlirRegisterConversionTosaToLinalgNamed(void) {
  registerTosaToLinalgNamed();
}


MlirPass mlirCreateConversionTosaToSCF(void) {
  return wrap(tosa::createTosaToSCF().release());
}
void mlirRegisterConversionTosaToSCF(void) {
  registerTosaToSCF();
}


MlirPass mlirCreateConversionTosaToTensor(void) {
  return wrap(tosa::createTosaToTensor().release());
}
void mlirRegisterConversionTosaToTensor(void) {
  registerTosaToTensor();
}

